<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnyDesk Detection System</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>üéØ AnyDesk Detection System</h1>
        <p>Advanced keystroke timing analysis to detect AnyDesk remote desktop sessions</p>
        
        <div class="detection-area">
            <textarea 
                id="inputField" 
                placeholder="Type continuously here to analyze for AnyDesk patterns... Need 30+ keystrokes for accurate detection"
                rows="3"
            ></textarea>
            
            <div class="status">
                <div class="status-indicator" id="statusIcon">‚è≥</div>
                <div class="status-text" id="statusText">Waiting for input...</div>
                <div class="progress-info" id="progressInfo">0 keystrokes</div>
            </div>
            
            <div class="results" id="results" style="display: none;">
                <h3>Detection Results</h3>
                <div class="metric">
                    <span>Detection Status:</span>
                    <span id="detectionResult">-</span>
                </div>
                <div class="metric">
                    <span>Confidence Level:</span>
                    <span id="confidenceLevel">-</span>
                </div>
                <div class="metric">
                    <span>Primary Indicators:</span>
                    <span id="primaryIndicators">-</span>
                </div>
            </div>
            
            <div class="technical-details" id="technicalDetails" style="display: none;">
                <h4>Technical Analysis</h4>
                <div class="details-grid">
                    <div class="detail-item">
                        <label>60Hz Pattern Match:</label>
                        <span id="frameRatePattern">-</span>
                    </div>
                    <div class="detail-item">
                        <label>16ms Quantization:</label>
                        <span id="quantizationPattern">-</span>
                    </div>
                    <div class="detail-item">
                        <label>DeskRT Signatures:</label>
                        <span id="deskrtSignatures">-</span>
                    </div>
                    <div class="detail-item">
                        <label>Latency Profile:</label>
                        <span id="latencyProfile">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AnyDeskDetector {
            constructor() {
                this.keystrokeData = [];
                this.minSamples = 30;
                this.isAnalyzing = false;
                
                // AnyDesk-specific constants from research
                this.ANYDESK_FRAME_INTERVAL = 16.67; // 60fps = 16.67ms intervals
                this.ANYDESK_MIN_LATENCY = 16; // Sub-16ms local network latency
                this.ANYDESK_BUFFER_SIZE = 100; // 100kb/s minimum bandwidth
                this.DESKTRT_QUANTIZATION = [8, 16, 24, 32]; // DeskRT timing patterns
                
                this.setupEventListeners();
                this.updateStatus('waiting', 'Type to begin AnyDesk detection...');
            }
            
            setupEventListeners() {
                const inputField = document.getElementById('inputField');
                
                inputField.addEventListener('keydown', (e) => {
                    this.captureKeystroke(e, 'keydown');
                });
                
                inputField.addEventListener('keyup', (e) => {
                    this.captureKeystroke(e, 'keyup');
                });
            }
            
            captureKeystroke(event, type) {
                const timestamp = performance.now();
                
                const keystroke = {
                    timestamp,
                    type,
                    key: event.key,
                    code: event.code,
                    which: event.which,
                    trusted: event.isTrusted,
                    detail: event.detail || 0,
                    timeStamp: event.timeStamp
                };
                
                this.keystrokeData.push(keystroke);
                this.updateProgress();
                
                if (this.keystrokeData.length >= this.minSamples && !this.isAnalyzing) {
                    this.performAnalysis();
                }
            }
            
            updateProgress() {
                const count = this.keystrokeData.length;
                const progressInfo = document.getElementById('progressInfo');
                progressInfo.textContent = `${count} keystrokes`;
                
                if (count < this.minSamples) {
                    this.updateStatus('collecting', `Collecting data... ${count}/${this.minSamples}`);
                }
            }
            
            performAnalysis() {
                this.isAnalyzing = true;
                this.updateStatus('analyzing', 'Analyzing for AnyDesk patterns...');
                
                setTimeout(() => {
                    const results = this.analyzeForAnyDesk();
                    this.displayResults(results);
                    this.isAnalyzing = false;
                }, 1000);
            }
            
            analyzeForAnyDesk() {
                const timings = this.extractTimings();
                const indicators = {
                    frameRateMatch: this.detectFrameRatePattern(timings),
                    quantizationPattern: this.detectQuantizationPattern(timings),
                    deskrtSignatures: this.detectDeskRTSignatures(timings),
                    latencyProfile: this.analyzeLatencyProfile(timings),
                    bufferCharacteristics: this.analyzeBufferPatterns(timings)
                };
                
                const confidence = this.calculateConfidence(indicators);
                const isAnyDesk = confidence > 0.7;
                
                return {
                    isAnyDesk,
                    confidence,
                    indicators,
                    rawTimings: timings
                };
            }
            
            extractTimings() {
                const timings = [];
                for (let i = 1; i < this.keystrokeData.length; i++) {
                    const interval = this.keystrokeData[i].timestamp - this.keystrokeData[i-1].timestamp;
                    timings.push(interval);
                }
                return timings;
            }
            
            detectFrameRatePattern(timings) {
                // AnyDesk runs at 60fps (16.67ms intervals)
                const targetInterval = this.ANYDESK_FRAME_INTERVAL;
                const tolerance = 3.0; // ¬±3ms tolerance
                
                let matches = 0;
                timings.forEach(timing => {
                    const quantized = Math.round(timing / targetInterval) * targetInterval;
                    if (Math.abs(timing - quantized) <= tolerance) {
                        matches++;
                    }
                });
                
                const matchRate = matches / timings.length;
                return {
                    detected: matchRate > 0.4,
                    strength: matchRate,
                    description: `${(matchRate * 100).toFixed(1)}% match to 60fps pattern`
                };
            }
            
            detectQuantizationPattern(timings) {
                // DeskRT codec uses specific quantization patterns
                let quantizedMatches = 0;
                
                timings.forEach(timing => {
                    this.DESKTRT_QUANTIZATION.forEach(quantum => {
                        if (Math.abs(timing % quantum) < 2) {
                            quantizedMatches++;
                        }
                    });
                });
                
                const quantizationRate = quantizedMatches / (timings.length * this.DESKTRT_QUANTIZATION.length);
                return {
                    detected: quantizationRate > 0.25,
                    strength: quantizationRate,
                    description: `${(quantizationRate * 100).toFixed(1)}% DeskRT quantization match`
                };
            }
            
            detectDeskRTSignatures(timings) {
                // Look for DeskRT-specific compression timing signatures
                const compressionPatterns = [
                    this.detectBurstPattern(timings),
                    this.detectCompressionCycles(timings),
                    this.detectFrameBuffering(timings)
                ];
                
                const detectedPatterns = compressionPatterns.filter(p => p.detected).length;
                return {
                    detected: detectedPatterns >= 2,
                    strength: detectedPatterns / compressionPatterns.length,
                    description: `${detectedPatterns}/3 DeskRT signatures detected`
                };
            }
            
            detectBurstPattern(timings) {
                // AnyDesk sends keystrokes in optimized bursts
                let burstCount = 0;
                let currentBurst = 0;
                
                timings.forEach(timing => {
                    if (timing < 5) { // Very fast succession
                        currentBurst++;
                    } else {
                        if (currentBurst >= 3) burstCount++;
                        currentBurst = 0;
                    }
                });
                
                return {
                    detected: burstCount > 0,
                    strength: burstCount / Math.max(1, timings.length / 10)
                };
            }
            
            detectCompressionCycles(timings) {
                // Look for periodic compression cycles (DeskRT specific)
                const cycleLengths = [250, 500, 1000]; // Common DeskRT cycle times
                let cycleMatches = 0;
                
                cycleLengths.forEach(cycleLength => {
                    const windows = Math.floor(timings.length / 10);
                    for (let i = 0; i < windows; i++) {
                        const start = i * 10;
                        const window = timings.slice(start, start + 10);
                        const avgTiming = window.reduce((a, b) => a + b, 0) / window.length;
                        
                        if (Math.abs(avgTiming - cycleLength / 60) < 5) {
                            cycleMatches++;
                        }
                    }
                });
                
                return {
                    detected: cycleMatches > 0,
                    strength: cycleMatches / Math.max(1, Math.floor(timings.length / 10))
                };
            }
            
            detectFrameBuffering(timings) {
                // AnyDesk's frame buffering creates specific timing patterns
                const bufferSizes = [16, 32, 64]; // Frame buffer sizes in ms
                let bufferMatches = 0;
                
                timings.forEach(timing => {
                    bufferSizes.forEach(buffer => {
                        if (Math.abs(timing % buffer) < 3) {
                            bufferMatches++;
                        }
                    });
                });
                
                return {
                    detected: bufferMatches > timings.length * 0.2,
                    strength: bufferMatches / (timings.length * bufferSizes.length)
                };
            }
            
            analyzeLatencyProfile(timings) {
                // AnyDesk has sub-16ms latency on local networks
                const lowLatencyCount = timings.filter(t => t < this.ANYDESK_MIN_LATENCY).length;
                const avgLatency = timings.reduce((a, b) => a + b, 0) / timings.length;
                
                const isLowLatency = avgLatency < 50 && lowLatencyCount > timings.length * 0.3;
                
                return {
                    detected: isLowLatency,
                    strength: lowLatencyCount / timings.length,
                    description: `Avg: ${avgLatency.toFixed(1)}ms, ${lowLatencyCount} sub-16ms events`
                };
            }
            
            analyzeBufferPatterns(timings) {
                // AnyDesk's efficient buffering creates consistent patterns
                const variance = this.calculateVariance(timings);
                const consistency = 1 / (1 + variance / 100); // Lower variance = higher consistency
                
                return {
                    detected: consistency > 0.6,
                    strength: consistency,
                    description: `Timing consistency: ${(consistency * 100).toFixed(1)}%`
                };
            }
            
            calculateVariance(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
                return squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
            }
            
            calculateConfidence(indicators) {
                const weights = {
                    frameRateMatch: 0.25,
                    quantizationPattern: 0.25,
                    deskrtSignatures: 0.20,
                    latencyProfile: 0.15,
                    bufferCharacteristics: 0.15
                };
                
                let totalConfidence = 0;
                Object.keys(weights).forEach(key => {
                    if (indicators[key] && indicators[key].strength !== undefined) {
                        totalConfidence += indicators[key].strength * weights[key];
                    }
                });
                
                return Math.min(0.95, totalConfidence);
            }
            
            displayResults(results) {
                const resultsDiv = document.getElementById('results');
                const technicalDiv = document.getElementById('technicalDetails');
                
                resultsDiv.style.display = 'block';
                technicalDiv.style.display = 'block';
                
                // Main results
                document.getElementById('detectionResult').textContent = 
                    results.isAnyDesk ? 'üéØ AnyDesk Detected' : '‚ùå AnyDesk Not Detected';
                document.getElementById('confidenceLevel').textContent = 
                    `${(results.confidence * 100).toFixed(1)}%`;
                
                // Primary indicators
                const primaryIndicators = [];
                if (results.indicators.frameRateMatch.detected) primaryIndicators.push('60fps Pattern');
                if (results.indicators.quantizationPattern.detected) primaryIndicators.push('DeskRT Quantization');
                if (results.indicators.deskrtSignatures.detected) primaryIndicators.push('Compression Signatures');
                if (results.indicators.latencyProfile.detected) primaryIndicators.push('Low Latency Profile');
                
                document.getElementById('primaryIndicators').textContent = 
                    primaryIndicators.length > 0 ? primaryIndicators.join(', ') : 'None';
                
                // Technical details
                document.getElementById('frameRatePattern').textContent = 
                    results.indicators.frameRateMatch.description;
                document.getElementById('quantizationPattern').textContent = 
                    results.indicators.quantizationPattern.description;
                document.getElementById('deskrtSignatures').textContent = 
                    results.indicators.deskrtSignatures.description;
                document.getElementById('latencyProfile').textContent = 
                    results.indicators.latencyProfile.description;
                
                // Update status
                if (results.isAnyDesk) {
                    this.updateStatus('detected', `AnyDesk detected with ${(results.confidence * 100).toFixed(1)}% confidence`);
                } else {
                    this.updateStatus('local', 'Local input detected - no AnyDesk patterns found');
                }
            }
            
            updateStatus(type, message) {
                const statusIcon = document.getElementById('statusIcon');
                const statusText = document.getElementById('statusText');
                
                const statusConfig = {
                    waiting: { icon: '‚è≥', class: 'waiting' },
                    collecting: { icon: 'üìä', class: 'collecting' },
                    analyzing: { icon: 'üîç', class: 'analyzing' },
                    detected: { icon: 'üéØ', class: 'anydesk' },
                    local: { icon: '‚úÖ', class: 'local' }
                };
                
                const config = statusConfig[type] || statusConfig.waiting;
                statusIcon.textContent = config.icon;
                statusIcon.className = `status-indicator ${config.class}`;
                statusText.textContent = message;
            }
        }
        
        // Initialize detector when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AnyDeskDetector();
        });
    </script>
</body>
</html> 
