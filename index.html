<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Desktop Detection</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>üîç Remote Desktop Detection</h1>
        <p>Analyzes keystroke timing patterns to detect AnyDesk, RDP, VNC sessions</p>
        
        <div class="input-area">
            <textarea 
                id="keyInput" 
                placeholder="Type continuously here... Need at least 50 keystrokes for accurate detection"
                rows="4"
            ></textarea>
                         <div class="progress">
                 <div class="progress-bar">
                     <div id="progressBar"></div>
                 </div>
                 <span id="progressText">0 / 50 keystrokes</span>
             </div>
        </div>

        <div class="results">
            <div class="status" id="status">
                <span class="indicator" id="indicator">‚è≥</span>
                <span class="text" id="statusText">Waiting for input...</span>
            </div>
            
            <div class="metrics">
                <div class="metric">
                    <label>Dominant Frequency:</label>
                    <span id="frequency">-</span>
                </div>
                <div class="metric">
                    <label>Timing Regularity:</label>
                    <span id="regularity">-</span>
                </div>
                <div class="metric">
                    <label>Network Latency Pattern:</label>
                    <span id="latency">-</span>
                </div>
                <div class="metric">
                    <label>Event Trust Ratio:</label>
                    <span id="trustRatio">-</span>
                </div>
            </div>
            
            <div class="confidence">
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                </div>
                <span id="confidenceText">No data</span>
            </div>
        </div>

        <div class="info">
            <h3>Detection Based On:</h3>
            <ul>
                <li><strong>USB Polling (125Hz):</strong> Regular intervals indicate USB input devices</li>
                <li><strong>RDP Quantization (64Hz):</strong> Windows process scheduling patterns</li>
                <li><strong>Network Buffering:</strong> Consistent timing due to packet buffering</li>
                <li><strong>Event Trust:</strong> Synthetic vs. hardware-generated events</li>
            </ul>
        </div>
    </div>

    <script>
        class RemoteDesktopDetector {
            constructor() {
                this.events = [];
                this.startTime = null;
                this.analysisResults = {
                    frequency: null,
                    regularity: 0,
                    latencyPattern: 0,
                    trustRatio: 1
                };
                
                this.init();
            }

            init() {
                const input = document.getElementById('keyInput');
                
                // Capture all keyboard events with high precision
                ['keydown', 'keyup'].forEach(eventType => {
                    input.addEventListener(eventType, (e) => {
                        this.captureEvent(e, eventType);
                    }, { passive: false, capture: true });
                });

                input.focus();
            }

            captureEvent(event, type) {
                const now = performance.now();
                
                if (!this.startTime) {
                    this.startTime = now;
                }

                const eventData = {
                    timestamp: now,
                    type: type,
                    key: event.key,
                    code: event.code,
                    trusted: event.isTrusted,
                    timeStamp: event.timeStamp,
                    detail: event.detail || 0
                };

                this.events.push(eventData);
                
                // Keep last 200 events
                if (this.events.length > 200) {
                    this.events.shift();
                }

                this.updateProgress();
                
                if (this.events.length >= 10) {
                    this.analyze();
                }
            }

            updateProgress() {
                const keystrokeCount = Math.floor(this.events.length / 2); // 2 events per keystroke
                const progress = Math.min(keystrokeCount / 50, 1) * 100;
                
                document.getElementById('progressBar').style.width = progress + '%';
                document.getElementById('progressText').textContent = `${keystrokeCount} / 50 keystrokes`;
            }

            analyze() {
                this.calculateFrequencyDomain();
                this.calculateTimingRegularity();
                this.calculateNetworkLatencyPattern();
                this.calculateEventTrustRatio();
                this.updateDisplay();
            }

            calculateFrequencyDomain() {
                if (this.events.length < 20) return;

                // Get keydown events only
                const keydowns = this.events.filter(e => e.type === 'keydown');
                if (keydowns.length < 10) return;

                // Calculate inter-keystroke intervals
                const intervals = [];
                for (let i = 1; i < keydowns.length; i++) {
                    intervals.push(keydowns[i].timestamp - keydowns[i-1].timestamp);
                }

                // Simple power spectral density for common remote desktop frequencies
                const testFrequencies = {
                    '125Hz': 8.0,    // USB polling (1000/125 = 8ms)
                    '100Hz': 10.0,   // Common polling
                    '64Hz': 15.625,  // Windows quantum (1000/64)
                    '60Hz': 16.67,   // Browser/display refresh
                    '50Hz': 20.0     // Some systems
                };

                let maxPower = 0;
                let dominantFreq = null;

                Object.entries(testFrequencies).forEach(([freq, expectedInterval]) => {
                    const power = this.calculatePowerAtFrequency(intervals, expectedInterval);
                    if (power > maxPower) {
                        maxPower = power;
                        dominantFreq = freq;
                    }
                });

                this.analysisResults.frequency = dominantFreq;
                this.analysisResults.frequencyPower = maxPower;
            }

            calculatePowerAtFrequency(intervals, targetInterval) {
                // Count intervals that are close to target (within 25% tolerance)
                const tolerance = targetInterval * 0.25;
                let matches = 0;
                
                intervals.forEach(interval => {
                    if (Math.abs(interval - targetInterval) < tolerance) {
                        matches++;
                    }
                    // Also check multiples (2x, 3x the interval)
                    if (Math.abs(interval - targetInterval * 2) < tolerance * 2) {
                        matches += 0.5;
                    }
                    if (Math.abs(interval - targetInterval * 3) < tolerance * 3) {
                        matches += 0.3;
                    }
                });

                return matches / intervals.length;
            }

            calculateTimingRegularity() {
                if (this.events.length < 20) return;

                const keydowns = this.events.filter(e => e.type === 'keydown');
                if (keydowns.length < 10) return;

                const intervals = [];
                for (let i = 1; i < keydowns.length; i++) {
                    intervals.push(keydowns[i].timestamp - keydowns[i-1].timestamp);
                }

                // Calculate coefficient of variation
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / intervals.length;
                const stdDev = Math.sqrt(variance);
                const cv = stdDev / mean;

                // Remote desktops often have MORE regular timing (lower CV)
                // due to network buffering and quantization
                this.analysisResults.regularity = Math.max(0, 1 - cv);
            }

            calculateNetworkLatencyPattern() {
                if (this.events.length < 30) return;

                const keydowns = this.events.filter(e => e.type === 'keydown');
                if (keydowns.length < 15) return;

                // Look for minimum latency patterns
                const intervals = [];
                for (let i = 1; i < keydowns.length; i++) {
                    intervals.push(keydowns[i].timestamp - keydowns[i-1].timestamp);
                }

                const minInterval = Math.min(...intervals);
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;

                // Remote sessions rarely have sub-10ms intervals due to network overhead
                // Local sessions can have much faster intervals
                let latencyScore = 0;
                
                if (minInterval > 15 && avgInterval > 40) {
                    latencyScore = 0.8; // High likelihood of remote session
                } else if (minInterval > 10 && avgInterval > 25) {
                    latencyScore = 0.5; // Medium likelihood
                } else if (minInterval < 5) {
                    latencyScore = 0.1; // Unlikely to be remote (very fast local input)
                } else {
                    latencyScore = 0.3; // Uncertain
                }

                this.analysisResults.latencyPattern = latencyScore;
            }

            calculateEventTrustRatio() {
                if (this.events.length < 10) return;

                const trustedEvents = this.events.filter(e => e.trusted).length;
                this.analysisResults.trustRatio = trustedEvents / this.events.length;
            }

            calculateOverallConfidence() {
                const weights = {
                    frequency: 0.3,
                    regularity: 0.25,
                    latency: 0.3,
                    trust: 0.15
                };

                let confidence = 0;

                // Frequency analysis
                if (this.analysisResults.frequency) {
                    const freqScore = this.analysisResults.frequencyPower || 0;
                    // 125Hz and 64Hz are strong indicators of remote desktop
                    if (this.analysisResults.frequency === '125Hz' || this.analysisResults.frequency === '64Hz') {
                        confidence += freqScore * weights.frequency * 1.5;
                    } else {
                        confidence += freqScore * weights.frequency;
                    }
                }

                // Regularity (high regularity suggests remote)
                confidence += this.analysisResults.regularity * weights.regularity;

                // Latency pattern
                confidence += this.analysisResults.latencyPattern * weights.latency;

                // Event trust (lower trust ratio suggests synthetic events)
                const trustScore = this.analysisResults.trustRatio < 0.9 ? (1 - this.analysisResults.trustRatio) : 0;
                confidence += trustScore * weights.trust;

                return Math.min(confidence, 1);
            }

            updateDisplay() {
                // Update metrics
                document.getElementById('frequency').textContent = 
                    this.analysisResults.frequency || 'Analyzing...';
                
                document.getElementById('regularity').textContent = 
                    (this.analysisResults.regularity * 100).toFixed(1) + '%';
                
                document.getElementById('latency').textContent = 
                    (this.analysisResults.latencyPattern * 100).toFixed(1) + '%';
                
                document.getElementById('trustRatio').textContent = 
                    (this.analysisResults.trustRatio * 100).toFixed(1) + '%';

                // Calculate and display overall confidence
                const confidence = this.calculateOverallConfidence();
                const confidenceFill = document.getElementById('confidenceFill');
                const confidenceText = document.getElementById('confidenceText');
                const indicator = document.getElementById('indicator');
                const statusText = document.getElementById('statusText');

                confidenceFill.style.width = (confidence * 100) + '%';
                confidenceText.textContent = (confidence * 100).toFixed(1) + '% confidence';

                const keystrokeCount = Math.floor(this.events.length / 2);
                
                if (keystrokeCount < 25) {
                    indicator.textContent = '‚è≥';
                    statusText.textContent = 'Collecting data... Keep typing';
                    indicator.className = 'indicator waiting';
                } else if (confidence > 0.6) {
                    indicator.textContent = 'üñ•Ô∏è';
                    statusText.textContent = 'Remote Desktop Detected';
                    indicator.className = 'indicator remote';
                } else if (confidence > 0.3) {
                    indicator.textContent = '‚ùì';
                    statusText.textContent = 'Uncertain - Mixed signals';
                    indicator.className = 'indicator uncertain';
                } else {
                    indicator.textContent = 'üíª';
                    statusText.textContent = 'Local Input Detected';
                    indicator.className = 'indicator local';
                }
            }
        }

        // Initialize detector when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RemoteDesktopDetector();
        });
    </script>
</body>
</html> 
